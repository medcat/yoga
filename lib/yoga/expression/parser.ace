
%require "~> 0.1"
%type "ruby"

%terminal STAR "*"
%terminal PLUS "+"
%terminal OPTIONAL "?"
%terminal UNION "|"
%terminal INTERSECT "&"
%terminal SDIFFERENCE "--"
%terminal DIFFERENCE "-"
%terminal LPAREN "("
%terminal RPAREN ")"
%terminal LBRACK "["
%terminal RBRACK "]"
%terminal INVERT "^"
%terminal ESCAPED
%terminal CHARACTER
%terminal STRING
%terminal CONTAIN
%terminal NUMBER

%left UNION INTERSECT SDIFFERENCE DIFFERENCE
%right CHARACTER NUMBER
%left STAR PLUS OPTIONAL
%nonassoc LPAREN RPAREN

%%

expression: group            { |_|    [_]          }
          | group expression { |a, b| b.unshift(a) }

group: group modifier        { |a, b|    compile_modifier(b, a) }
     | group binop group     { |a, b, c| compile_binop(b, a, c) }
     | value

modifier: STAR       { |_| _[0] }
        | PLUS       { |_| _[0] }
        | OPTIONAL   { |_| _[0] }

binop: UNION       { |_| _[0] }
     | INTERSECT   { |_| _[0] }
     | SDIFFERENCE { |_| _[0] }
     | DIFFERENCE  { |_| _[0] }

value: LPAREN expression RPAREN { |_, a, _| compile_paren(a)      }
     | STRING                   { |_|       compile_string(_)     }
     | contain                  { |_|       compile_contain(_)    }
     | NUMBER                   { |_|       compile_number(_)     }
     | identifier               { |_|       compile_identifier(_) }

contain: LBRACK contain.body RBRACK { |_, a, _| a }

identifier: CHARACTER chars     { |a, b| b.unshift(a)             }

chars: char                     { |_|    [_]                      }
     | char chars               { |a, b| b.unshift(a)             }

char: CHARACTER
    | NUMBER
    | DIFFERENCE

contain.body: INVERT contain.parts          { |a, b| b.unshift(a) }
            | contain.parts

contain.parts: contain.part                 { |_|    [_]          }
             | contain.part contain.parts   { |a, b| b.unshift(a) }

contain.part: contain.char
            | contain.char DIFFERENCE contain.char
                { |a, b, c| [:SET, a[1], c[1]] }
            | DIFFERENCE

contain.char: CHARACTER
            | NUMBER
            | ESCAPED

%%

module Yoga
  class Expression
    module Parser
      %{write}

      def type(token)
        token[0].to_s.upcase.intern
      end
    end
  end
end
